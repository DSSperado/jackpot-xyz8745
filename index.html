<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>슬롯머신</title>
<style>
  :root{
    /* ▷ 릴 위치/크기: 프레임 대비 ‘퍼센트(%)’ 값 (초기값: 대충 맞춘 값) */
    --REEL_TOP_PCT: 35.4;     /* 프레임 높이 대비 위쪽 여백(%) */
    --REEL_LEFT0_PCT: 16;   /* 첫 릴의 좌측 위치(%) */
    --REEL_W_PCT: 15.8;       /* 릴 너비(%) */
    --REEL_H_PCT: 18.6;       /* 릴 높이(%) */
    --REEL_GAP_PCT: 7.2;      /* 릴 사이 간격(%) */
    --STATUS_LEFT: 30%;      /* X 좌표 (가운데 정렬하려면 % 사용) */
    --STATUS_TOP:  74.6%;      /* Y 좌표: 프레임 높이 대비 */
    --STATUS_W:    375px;    /* 박스 너비 */
    --STATUS_H:    130px;     /* 박스 높이 */
    --s: 1;    /* 스케일러 */
  }

  html,body{height:100%;margin:0;background:#fff4e0;font-family:system-ui,Pretendard,Noto Sans KR,sans-serif; overflow: hidden; }
  body{
  min-height: 100svh;            /* 모바일 주소창 높이 이슈 대응 */
  margin: 0;
  display: flex;
  flex-direction: column;         /* 프레임 위, 버튼 아래 세로 정렬 */
  justify-content: center;        /* 세로 중앙 */
  align-items: center;            /* 가로 중앙 */
  gap: 12px;                      /* 프레임과 버튼 사이 간격 */
  padding: 16px 12px;             /* 가장자리 여백 (작은 화면 보호) */
  background: #ffffff;            /* 기존 배경 유지 */
  }
  #stage{
    width:750px;
    height:1200px;
    position:absolute;
    left:50%; top:54%;
    transform:translate(-50%,-50%) scale(var(--s));
    transform-origin:50% 50%;
  }
  .slot-wrap{
    position: relative;
    width: min(95vw, 750px);
    aspect-ratio: 380 / 540;
    margin: 0;
  }

  /* 프레임 이미지를 꽉 채움 */
  .slot-frame{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    pointer-events:none; user-select:none;
    border-radius:10px;
  }

  /* 릴 3개: 퍼센트 기반 위치 */
  .reel{
    position:absolute;
    top: calc(var(--REEL_TOP_PCT) * 1%);
    width: calc(var(--REEL_W_PCT) * 1%);
    height: calc(var(--REEL_H_PCT) * 1%);
    display:grid; place-items:center;
    background:#fff; border-radius:10px;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    font-size: clamp(36px, 7vw, 60px);
    line-height:1; overflow:hidden;
  }
  .reel.r0{ left: calc(var(--REEL_LEFT0_PCT) * 1%); }
  .reel.r1{ left: calc((var(--REEL_LEFT0_PCT) + var(--REEL_W_PCT) + var(--REEL_GAP_PCT)) * 1%); }
  .reel.r2{ left: calc((var(--REEL_LEFT0_PCT) + (var(--REEL_W_PCT) + var(--REEL_GAP_PCT)) * 2) * 1%); }

  .face{ position:relative; width:100%; height:100%; display:grid; place-items:center; transition: transform 0.35s ease-out; }
  .sym-label { display: none; }


  /* 회전 중 살짝 흔들림 */
  .reel.spinning .face{ animation:shimmy 200ms linear infinite; }
  @keyframes shimmy { 0%{transform:translateY(-2%)} 50%{transform:translateY(2%)} 100%{transform:translateY(-2%)} }

  /* 컨트롤 */
  .ctrl{ position: relative; display:flex; gap:12px; justify-content:center; align-items:center; margin:10px auto 0; width:min(90vw, 520px); height: 80px; }
  button{ cursor:pointer; border:0; border-radius:12px; padding:12px 22px; font-weight:800; background:#e63946; color:#fff; box-shadow:0 4px 0 #a31628; }
  .ctrl button {
    position: absolute;
    font-size: 1.5rem;   /* 글자 크기 키우기 */
    padding: 16px 28px;  /* 세로·가로 여백 확대 */
    left: 170px;
    top: -30px;
  }
  button:active{ transform:translateY(2px); box-shadow:0 2px 0 #a31628; }
  .status{
    color: #fff;             /* 흰색 글씨 */
    font-size: 2.5rem;
    font-weight: 900;
  }
  .status.win{ color:#fff; } .status.lose{ color:#fff; }
  .status-box{
    position: absolute;
    left: calc(var(--STATUS_LEFT) - var(--STATUS_W)/2); /* 가운데 정렬용 */
    top: var(--STATUS_TOP);
    width: var(--STATUS_W);
    height: var(--STATUS_H);
    background: #df3b1b;     /* 빨간색 */
    border-radius: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 10px rgba(0,0,0,.15);
    z-index: 5;
  }

  /* === 위치 조정 모드(캘리브레이터) === */
  .cal{ width:min(90vw, 520px); margin:12px auto; background:#fff; border:1px solid #ffdca8; border-radius:12px; padding:10px; }
  .cal h3{ margin:4px 0 8px; font-size:14px }
  .cal .row{ display:grid; grid-template-columns:140px 1fr 60px; gap:10px; align-items:center; margin:6px 0; }
  .cal input[type=range]{ width:100% }
  .cal small{ opacity:.7 }
  .guide-on .reel{ outline:2px dashed #3b82f6aa; }
  .strip {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    will-change: transform;
  }
  .strip .item{
    width: 100%; height: var(--H,100%);
    display:flex; place-items: center;
    font-size: clamp(36px,7vw,60px);
    align-items:center;
    justify-content:center;
    line-height:1; 
  }
  .strip .item > img, 
  .strip .item > span{ display:block; }
  .strip .item img{ width:95%; height:auto; display:block; margin:0 auto; }

  @keyframes centerPop {
    0%   { transform: scale(1); }
    30%  { transform: scale(1.25); }
    60%  { transform: scale(1.08); }
    100% { transform: scale(1); }
  }

  .strip .item.hit {
    animation: centerPop 650ms cubic-bezier(.2,1,.2,1);
    transform-origin: 50% 50%;
    z-index: 1;
  }

  /* 카드 주변 황금빛 글로우(잠깐 번쩍) */
  @keyframes haloBlink {
    0%   { opacity: 0; transform: scale(.9); }
    35%  { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(1.05); }
  }

  /* 각 릴 중앙에 맞춘 글로우 오버레이 */
  .slot-wrap.win .reel::before{
    content:"";
    position:absolute; inset:0;
    pointer-events:none;
    /* 중앙 카드 영역만 강조되도록 안쪽을 남기고 바깥쪽을 부드럽게 번짐 */
    background:
      radial-gradient(ellipse at 50% 50%,
        rgba(255,230,140,.85) 0%,
        rgba(255,210,70,.55) 40%,
        rgba(255,210,70,.20) 60%,
        rgba(255,210,70,0) 80%);
    filter: blur(.4px);
    border-radius: 10px;
    animation: haloBlink 680ms ease-out 1;
  }

  /* 중앙에 멈춘 '그 카드'만 팝 효과 */
  .strip .item.hit {
    animation: centerPop 650ms cubic-bezier(.2,1,.2,1);
    transform-origin: 50% 50%;
    z-index: 1; /* 겹침 우선 */
  }
  .weight-panel{
    position: fixed; top: 40px; right: 40px;
    width: 360px; background:#fff; border:1px solid #ddd; border-radius:10px;
    padding:16px; box-shadow:0 3px 8px rgba(0,0,0,.12); z-index:100; font-size:16px;
  }
  .weight-panel h3{ margin:0 0 10px; font-size:18px; }
  .weight-panel .row{
    display:grid;
    grid-template-columns: 1fr auto auto; /* 왼쪽: name / 가운데: wwrap / 오른쪽: pct */
    align-items:center;
    margin:15px 0; padding:4px 0;
    column-gap:16px;                     /* ← name~x1, x1~% 사이 여백 */
  }
  .weight-panel .row:last-child{ border-bottom:0; }
  .weight-panel .name{ justify-self: start; }
  .weight-panel .btn{
    width:42px; height:38px; border-radius:8px; border:1px solid #ddd; background:#f7f7f7; cursor:pointer;
  }
  /* x1 자체를 왼쪽에 딱 붙이기 */
  .weight-panel .w{
    min-width: 48px;                     /* 너무 넓어서 우측에 붙던 것 줄이기 */
    text-align: left;                    /* ← right → left */
  }
  .weight-panel .w:focus{ border-color:#60a5fa; box-shadow:0 0 0 3px #93c5fd55; }
  .weight-panel .x{ opacity:.7; }
  /* 확률은 오른쪽 끝에 고정 */
  .weight-panel .pct{
    justify-self: end;
    min-width: 60px;
    text-align: right;
  }
  .weight-panel .help{ margin-top:10px; font-size:12px; opacity:.7; }
  
  /* x1 묶음: 가운데 정렬 → 왼쪽 정렬로 */
  .weight-panel .wwrap{
    justify-self: start;                 /* ← center → start */
    position: relative;
    display: inline-flex;
    align-items: center;
    font-weight:500;
  }

  .weight-panel .updown {
    position: absolute;
    right: 5px;                 /* 숫자 오른쪽에 붙이기 */
    top: 50%;
    transform: translateY(-50%);
    
    display: flex;
    flex-direction: column;       /* ← 핵심: 세로 배치 */
    gap: 0px;

    opacity: 0;
    pointer-events: none;
    transition: opacity .15s ease;
  }

  /* 호버하면 나타남 */
  .weight-panel .wwrap:hover .updown{
    opacity: 1;
    pointer-events: auto;
  }

  /* 작은 원형 버튼 */
  .weight-panel .updown .btn {
    width: 22px;
    height: 22px;
    border-radius: 999px;
    border: 1px solid #cfcfcf;
    background: #fff;
    padding: 0;
    cursor: pointer;
    box-shadow: 0 1px 2px rgba(0,0,0,.08);

    /* 글자 잘 보이게 */
    font-size: 16px;       /* 크기 조정 */
    font-weight: 500;     /* 굵게 */
    line-height: 1;        /* 세로 가운데 */
    color: #333;           /* 글자색 */
  }
  .weight-panel .updown .btn:hover{ background:#f5f5f5; }

</style>
</head>
<body>

<div id="stage">
  <div class="slot-wrap" id="wrap">
    <img class="slot-frame" src="KakaoTalk_20250919_112415354.png" alt="frame">

    <!-- 릴(카드) 3개 -->
    <div class="reel r0" id="reel0"></div>
    <div class="reel r1" id="reel1"></div>
    <div class="reel r2" id="reel2"></div>

    <div class="status-box" id="statusBox">
      <div class="status" id="status">READY</div>
    </div>
  </div>

  <div class="ctrl">
    <button id="btn">START</button>
  </div>
</div>

<!-- 위치 조정 패널 -->
<div class="cal" id="cal" hidden>
  <h3>📐 위치 조정 (프레임 대비 %)</h3>
  <div class="row"><label>TOP(%)</label><input id="rTop" type="range" min="0" max="100" step="0.1"><output id="oTop"></output></div>
  <div class="row"><label>LEFT0(%)</label><input id="rLeft" type="range" min="0" max="100" step="0.1"><output id="oLeft"></output></div>
  <div class="row"><label>WIDTH(%)</label><input id="rW" type="range" min="1" max="50" step="0.1"><output id="oW"></output></div>
  <div class="row"><label>HEIGHT(%)</label><input id="rH" type="range" min="1" max="60" step="0.1"><output id="oH"></output></div>
  <div class="row"><label>GAP(%)</label><input id="rGap" type="range" min="0" max="30" step="0.1"><output id="oGap"></output></div>
  <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
    <button id="btnCopy" style="background:#16a34a">값 복사</button>
    <small>저장은 자동(브라우저 로컬). 가이드선은 위치조정 ON일 때 보입니다.</small>
  </div>
</div>

<!-- 가중치(칸 수) 패널 -->
<div class="weight-panel" id="weightPanel">
  <h3>슬롯머신 확률 (사용자 조정)</h3>
  <div class="rows">
    <!-- data-key 만 우리 심볼 키로 맞추면 됨 -->
    <div class="row" data-key="miss"><span class="name">꽝</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
    <div class="row" data-key="chicken"><span class="name">치킨</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
    <div class="row" data-key="coffee"><span class="name">커피</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
    <div class="row" data-key="coin"><span class="name">코인</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
    <div class="row" data-key="dahye"><span class="name">다혜</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
    <div class="row" data-key="bomb"><span class="name">폭탄</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
    <div class="row" data-key="seven"><span class="name">7</span><span class="wwrap"><span class="w">x1</span><div class="updown"><button class="btn plus">+</button><button class="btn minus">−</button></div></span><output class="pct">0%</output></div>
  </div>
  <div class="help">Ait+클릭 ±100  /  Ctrl+클릭 ±10 / 클릭 ±1 </div>
</div>

<script>
const BASE_W=900, BASE_H=1200, SCALE_BIAS=0.96;
function viewportSize(){
  const vv=window.visualViewport;
  return vv ? {w:vv.width*vv.scale, h:vv.height*vv.scale} :
               {w:window.innerWidth, h:window.innerHeight};
}
function fit(){
  const {w,h}=viewportSize();
  const raw=Math.min(w/BASE_W,h/BASE_H);
  document.documentElement.style.setProperty('--s', Math.min(raw*SCALE_BIAS,2));
}
window.addEventListener('resize',fit);
if(window.visualViewport){
  visualViewport.addEventListener('resize',fit);
  visualViewport.addEventListener('scroll',fit);
}
fit();

let finalKeys = [null, null, null];
// ===== 스핀/감속 설정 =====
const SPIN_TIME_BASE = 3000;   // 1번 릴의 빠른 회전 유지 시간(ms)
const SPIN_TIME_STEP = 300;    // 릴마다 조금씩 더 오래
const SPEED_PX  = 8000;   // 빠른 회전(위→아래) px/sec
const DECEL_TURNS_BASE = 6;      // 감속 구간에서 추가로 보이는 랜덤 아이템 줄 수(바퀴 수 느낌)
const DECEL_TURNS_RAND = 3;      // 감속 구간 랜덤 가산치(0~이 값-1)
const DECEL_MS_BASE = 950;    // 감속 애니메이션 시간(ms)
const DECEL_MS_STEP = 150;    // 릴마다 조금 더 길게(세 번째 릴이 가장 늦게 멈춤)

/* ───────── 릴 로직(간단) ───────── */
const SYMBOLS = [
  { key:'chicken', label:'치킨', glyph:'<img src="chicken.png" alt="치킨">' },
  { key:'coffee',  label:'커피',  glyph:'<img src="coffee.png"  alt="커피">' },
  { key:'coin',    label:'코인',  glyph:'<img src="coin.png"    alt="코인">' },
  { key:'dahye',   label:'다혜',  glyph:'<img src="dahye.png"   alt="다혜">' },
  { key:'bomb',    label:'폭탄',  glyph:'<img src="bomb.png"    alt="폭탄">' },
  { key:'seven',   label:'7',     glyph:'<img src="seven.png"   alt="7">' },
];
let dist = { wins:{ chicken:3, coffee:3, coin:4, dahye:1.5, bomb:1.5, seven:1 }, miss:86 };

const reels=[0,1,2].map(i=>document.getElementById('reel'+i));
const statusEl=document.getElementById('status');
const btn=document.getElementById('btn');
let busy=false;

const wrap = document.getElementById('wrap');

function finishFromVisible(){
  const [a,b,c] = finalKeys;
  if (a && a === b && b === c){
    status(`당첨! [${labelOf(a)}] x3`, true);
    wrap.classList.add('win');            // 글로우 효과

    // ★ 세 카드가 완전히 멈춘 후 한꺼번에 팝 효과
    const reelsEls = document.querySelectorAll('.reel');
    reelsEls.forEach(reel=>{
      const last = reel.querySelector('.strip .item:last-child');
      if(last) last.classList.add('hit');
    });
    setTimeout(()=>{
      reelsEls.forEach(reel=>{
        const last = reel.querySelector('.strip .item:last-child');
        if(last) last.classList.remove('hit');
      });
      wrap.classList.remove('win');
    }, 650); // 팝 지속 시간과 맞추기

  } else {
    status('꽝 (불일치)', false);
  }
}

btn.addEventListener('click', spin);
function spin(){
  if(busy) return; busy=true; btn.disabled = true; status('· · ·');
  finalKeys = [null, null, null];
  const outcome = drawOutcome(dist);
  const targets = (outcome.type === 'win') ? [outcome.symbol,outcome.symbol,outcome.symbol] : drawMissTriple();
  reels.forEach(el=>el.classList.add('spinning'));
  const stops=[900,1300,1700];
  targets.forEach((k,i)=> cycleReelTo(i,k,stops[i],()=>{
    if(i===2){ reels.forEach(el=>el.classList.remove('spinning')); finishFromVisible(); busy=false; btn.disabled = false; }
  }));
}
function finish(o){ status(o.type==='win'?`당첨! [${labelOf(o.symbol)}] x3`:'꽝 (불일치)', o.type==='win'); }
function status(msg,win){ statusEl.textContent=msg; if (win === true) statusEl.className = 'status win'; else if (win === false) statusEl.className = 'status lose'; }
function labelOf(key){ return SYMBOLS.find(s=>s.key===key)?.label||key; }
function cycleReelTo(idx, key, _unusedMs, done){
  const reel = reels[idx];
  const H = reel.offsetHeight;

  // ── PHASE A: 빠른 연속 회전(유지) — requestAnimationFrame로 무한 스크롤
  // stripLoop: 랜덤 아이템 여러 개를 쌓아 위→아래로 흐르게 만들고, 맨 위가 지나가면 뒤에 다시 붙임
  const stripLoop = document.createElement('div');
  stripLoop.className = 'strip';
  stripLoop.style.setProperty('--H', H + 'px');

  const pool = [];                     // 루프용 초기 목록
  for(let i=0;i<10;i++){
    const s = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
    pool.push(s);
  }
  stripLoop.innerHTML = pool.map(s=>`<div class="item">${s.glyph}</div>`).join('');
  reel.innerHTML = '';
  reel.appendChild(stripLoop);

  let y = 0;                           // 현재 스크롤 거리(px)
  let rafId = 0;
  let last = performance.now();
  const speed = SPEED_PX;              // px/sec
  const spinTime = SPIN_TIME_BASE + SPIN_TIME_STEP * idx; // 릴마다 조금 더 길게
  const spinEndAt = last + spinTime;

  function tick(now){
    const dt = (now - last) / 1000;    // 초 단위
    last = now;
    y += speed * dt;

    // 한 칸(=H) 넘어가면 맨 위 아이템 제거하고 맨 아래로 하나 더 추가 → 무한루프
    while (y >= H){
      y -= H;
      // 맨 위 제거 & 맨 아래 추가
      const lastEl = stripLoop.lastElementChild;
      if (lastEl) stripLoop.removeChild(lastEl);
      const s  = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
      const el = document.createElement('div');
      el.className = 'item';
      el.innerHTML = s.glyph;
      stripLoop.insertBefore(el, stripLoop.firstChild);
    }

    stripLoop.style.transform = `translateY(${Math.round(y)}px) translateY(${-H/2}px)`;

    if(now < spinEndAt){
      rafId = requestAnimationFrame(tick);
    }else{
      // PHASE A 종료 → PHASE B(감속 정지)로 전환
      phaseB();
    }
  }
  rafId = requestAnimationFrame(tick);

  // ── PHASE B: 감속하며 목표 심볼에서 부드럽게 정지
  function phaseB(){
    cancelAnimationFrame(rafId);

    const stripStop = document.createElement('div');
    stripStop.className = 'strip';
    stripStop.style.setProperty('--H', H + 'px');

    // 감속 구간에서 여러 아이템이 더 내려오다가 마지막에 목표가 보이게 구성
    const turns = DECEL_TURNS_BASE + Math.floor(Math.random()*DECEL_TURNS_RAND) + idx; // 릴마다 살짝 더 많게
    const seq = [];
    for(let i=0;i<turns;i++){
      const s = SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
      seq.push(s);
    }
    // 마지막은 무조건 목표 심볼
    const target = SYMBOLS.find(s=>s.key===key) || SYMBOLS[0];
    seq.push(target);

    stripStop.innerHTML = seq.map(s=>`<div class="item">${s.glyph}</div>`).join('');
    reel.innerHTML = '';
    reel.appendChild(stripStop);

    // 시작: 더 위쪽(-lead)에서 아래로 감속해 중앙에서 멈춤
    const total = H * (seq.length - 1); 
    const dur   = DECEL_MS_BASE + DECEL_MS_STEP * idx;
    const lead  = H * 4; // 감속 전에 더 많이 내려오게(원하면 2~6H로 조절)

    stripStop.style.transition = 'none';
    stripStop.style.transform = `translateY(${Math.round(-total)}px) translateY(${-H/2}px)`;

    requestAnimationFrame(()=>{
      stripStop.style.transition = `transform ${dur}ms cubic-bezier(.08,.9,.18,1)`;
      stripStop.style.transform  = `translate3d(0, ${-total}px, 0)`;      // 중앙에서 정지
    });

    // 정지 후: 중앙에 멈춘 '그 카드'만 팝 효과
    setTimeout(()=>{
      finalKeys[idx] = key;
      done && done();
    }, dur + 30);
  }
}

function drawOutcome(d){
  const sumWins = Object.values(d.wins).reduce((a,b)=>a+b,0);
  const r = Math.random() * 100;
  if (r < d.miss) return { type:'miss' };
  // 남은 구간(100 - miss)에서 win 심볼 가중 추출
  let rr = Math.random() * sumWins;
  for (const k of Object.keys(d.wins)){
    rr -= d.wins[k];
    if (rr <= 0) return { type:'win', symbol:k };
  }
  return { type:'miss' }; // fallback
}

function drawMissTriple(){
  const pick=()=>SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)].key;
  let a=pick(),b=pick(),c=pick();
  if(a===b&&b===c){ const others=SYMBOLS.filter(s=>s.key!==a); c=others[Math.floor(Math.random()*others.length)].key; }
  return [a,b,c];
}

/* ───────── 위치 조정(캘리브레이터) ───────── */
const cal = document.getElementById('cal');
const btnCal = document.getElementById('btnCal');
const root = document.documentElement;

const sliders = {
  top : {el:document.getElementById('rTop'), css:'--REEL_TOP_PCT', out:document.getElementById('oTop')},
  left: {el:document.getElementById('rLeft'), css:'--REEL_LEFT0_PCT', out:document.getElementById('oLeft')},
  w   : {el:document.getElementById('rW'), css:'--REEL_W_PCT', out:document.getElementById('oW')},
  h   : {el:document.getElementById('rH'), css:'--REEL_H_PCT', out:document.getElementById('oH')},
  gap : {el:document.getElementById('rGap'), css:'--REEL_GAP_PCT', out:document.getElementById('oGap')},
};

initSliders();
if (btnCal) btnCal.addEventListener('click', ()=> {
  const on = cal.toggleAttribute('hidden')===false; // hidden 제거되면 ON
  document.body.classList.toggle('guide-on', on);
});
const btnCopy = document.getElementById('btnCopy');
if (btnCopy) btnCopy.addEventListener('click', copyVars);

function initSliders(){
  // 기존 값(로컬 저장) 불러오기
  const saved = JSON.parse(localStorage.getItem('reelPosPct')||'{}');
  for(const k in sliders){
    const v = saved[sliders[k].css] ?? getPct(sliders[k].css);
    sliders[k].el.value = v;
    sliders[k].out.textContent = v + '%';
    root.style.setProperty(sliders[k].css, v);
    sliders[k].el.addEventListener('input', e=>{
      const val = e.target.value;
      root.style.setProperty(sliders[k].css, val);
      sliders[k].out.textContent = val + '%';
      saveVars();
    });
  }
}
function getPct(cssVar){
  const v = getComputedStyle(root).getPropertyValue(cssVar).trim();
  return v ? parseFloat(v) : 0;
}
function saveVars(){
  const data={};
  for(const k in sliders){ data[sliders[k].css] = parseFloat(sliders[k].el.value); }
  localStorage.setItem('reelPosPct', JSON.stringify(data));
}
function copyVars(){
  const s = `:root{
  --REEL_TOP_PCT: ${sliders.top.el.value};
  --REEL_LEFT0_PCT: ${sliders.left.el.value};
  --REEL_W_PCT: ${sliders.w.el.value};
  --REEL_H_PCT: ${sliders.h.el.value};
  --REEL_GAP_PCT: ${sliders.gap.el.value};
}`;
  navigator.clipboard.writeText(s);
  alert('CSS 변수를 복사했어요. 스타일시트에 붙여넣으세요.');
}
window.addEventListener('load', () => {
  reels.forEach(reel => {
    const H = reel.offsetHeight;
    const strip = document.createElement('div');
    strip.className = 'strip';
    strip.style.setProperty('--H', H + 'px');

    // 1) 무작위 심볼 1장
    const s = SYMBOLS[Math.floor(Math.random() * SYMBOLS.length)];

    // 2) 또는 '고정'으로 보여주고 싶으면 위 한 줄 대신 예: const s = SYMBOLS.find(x => x.key === 'chicken');
    strip.innerHTML = `<div class="item">${s.glyph}</div>`;

    reel.innerHTML = '';
    reel.appendChild(strip);
  });
});

// --- 가중치 패널 로직 ---
(function(){
  const panel = document.getElementById('weightPanel');
  if(!panel) return;

  // 현재 weight 읽기
  function readWeights(){
    const rows = [...document.querySelectorAll('#weightPanel .row')];
    const w = {};
    rows.forEach(r=>{
      const key = r.dataset.key;
      const raw = r.querySelector('.w').textContent.trim();
      const v = parseFloat(raw.replace(/[^\d.]/g, '')); // 'x113' -> 113
      w[key] = isNaN(v) ? 0 : v;
    });
    return w;
  }

  // weight → % 환산해서 UI/게임(dist)에 반영
  function applyWeights(){
    const rows = [...panel.querySelectorAll('.row')];
    const w = readWeights();
    let sum = Object.values(w).reduce((a,b)=>a+b,0);
    if (sum <= 0) { sum = 1; w.miss = 1; }   // 0 분모 방지

    // UI 표시 + dist 갱신(우리 슬롯 로직에 그대로 사용)
    rows.forEach(r=>{
      const key = r.dataset.key;
      const pct = (w[key] / sum) * 100;
      r.querySelector('.pct').value = (Math.round(pct*100)/100).toFixed(2) + '%';
    });

    // dist에 퍼센트 반영
    dist.miss         = (w.miss    / sum) * 100;
    dist.wins.chicken = (w.chicken / sum) * 100;
    dist.wins.coffee  = (w.coffee  / sum) * 100;
    dist.wins.coin    = (w.coin    / sum) * 100;
    dist.wins.dahye   = (w.dahye   / sum) * 100;
    dist.wins.bomb    = (w.bomb    / sum) * 100;
    dist.wins.seven   = (w.seven   / sum) * 100;
  }

  // 버튼(+/–) 클릭 → 가중치 증감
  panel.addEventListener('click', (e)=>{
    const btn = e.target.closest('.btn');
    if(!btn) return;
    const row = btn.closest('.row');
    const cell = row.querySelector('.w');

    let step = 1;
    if (e.altKey) step = 100;
    else if (e.ctrlKey || e.metaKey) step = 10;

    let v = parseFloat(cell.textContent.replace(/[^\d.]/g, "")) || 0;
    if (btn.classList.contains('plus')) {
      v += step;                      // 플러스면 증가
    } else if (btn.classList.contains('minus')) {
      v -= step;                      // 마이너스면 감소
    }
    if (v < 0) v = 0;

    cell.textContent = "x" + v;
    applyWeights();
  });

  // 가중치 숫자 직접 수정: Enter/blur 때 반영
  panel.addEventListener('keydown', (e)=>{
    if(e.key==='Enter' && e.target.classList.contains('w')){
      e.preventDefault(); e.target.blur();
    }
  });
  panel.addEventListener('blur', (e)=>{
    if(e.target.classList.contains('w')){
      let v = parseFloat(e.target.textContent.trim());
      if (isNaN(v) || v < 0) v = 0;
      e.target.textContent = (Math.round(v*100)/100).toString();
      applyWeights();
    }
  }, true);

  // 초기 1회 반영
  applyWeights();
})();

</script>
</body>
</html>
